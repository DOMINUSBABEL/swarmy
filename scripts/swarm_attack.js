const puppeteer = require('puppeteer');
const path = require('path');
const xlsx = require('xlsx');
const TWITTER_SELECTORS = require('../twitter_selectors.js');

// CONFIG
const DEFAULT_TARGET_URL = 'https://x.com/luisguillermovl/status/2022646985677840818';
const EXCEL_PATH = path.join(__dirname, '../Master_Social_Creds.xlsx');

// COMMENT BANK (Generated by Talleyrand for this mission)
const COMMENTS = {
    'acc_samuel': "La claridad conceptual es lo que necesitamos en el debate p√∫blico. Muy buen punto, doctor. üëè",
    'acc_mariate': "Totalmente de acuerdo. La ciudad necesita m√°s de esta visi√≥n y menos ruido. #Medellin",
    'acc_daniel': "Interesante planteamiento. ¬øC√≥mo se articular√≠a esto con el plan de inversiones actual? ü§î",
    'acc_nguerrero': "Esto es lo que nadie se atreve a decir. RT masivo.",
    'acc_revistavoces': "üì¢ [AHORA] El Concejal Luis Guillermo V√©lez marca la pauta sobre el debate de ciudad. Hilo recomendado üëá"
};

function validateTargetUrl(url) {
    try {
        const parsed = new URL(url);
        if (!['http:', 'https:'].includes(parsed.protocol)) {
            throw new Error(`Invalid protocol: ${parsed.protocol}`);
        }
        if (!['twitter.com', 'www.twitter.com', 'x.com', 'www.x.com'].includes(parsed.hostname)) {
            throw new Error(`Invalid domain: ${parsed.hostname}. Only x.com and twitter.com are allowed.`);
        }
        return parsed.href;
    } catch (e) {
        throw new Error(`Invalid Target URL: ${e.message}`);
    }
}

async function runSwarmAttack(targetUrlOrDeps = DEFAULT_TARGET_URL, deps = {}) {
    let targetUrl = DEFAULT_TARGET_URL;
    let actualDeps = deps;

    // Handle flexible arguments: (url, deps) or (deps) or ()
    if (typeof targetUrlOrDeps === 'string') {
        targetUrl = targetUrlOrDeps;
    } else if (typeof targetUrlOrDeps === 'object' && targetUrlOrDeps !== null) {
        actualDeps = targetUrlOrDeps;
        // targetUrl remains default
    }

    // Validate the target URL before proceeding
    validateTargetUrl(targetUrl);

    const p = actualDeps.puppeteer || puppeteer;
    const x = actualDeps.xlsx || xlsx;

    console.log(`üêù SWARM ATTACK INITIATED against: ${targetUrl}`);

    const workbook = x.readFile(EXCEL_PATH);
    const accounts = x.utils.sheet_to_json(workbook.Sheets['ACCOUNTS']);
    
    // Filter only our 5 REAL soldiers
    const squad = accounts.filter(a => ['acc_samuel', 'acc_mariate', 'acc_daniel', 'acc_nguerrero', 'acc_revistavoces'].includes(a.account_id));

    if (squad.length === 0) {
        console.error("‚ùå No active soldiers found.");
        return;
    }

    // Process sequentially to avoid RAM explosion
    let browser;
    try {
        browser = await p.launch({
            headless: false, // Visible for debugging/human-like behavior
        });

        for (const soldier of squad) {
            console.log(`\nü™ñ DEPLOYING: ${soldier.account_id}`);
            
            let context;
            try {
                // Create a new incognito browser context for each soldier
                context = await browser.createBrowserContext();
                const page = await context.newPage();
                await page.setViewport({ width: 1280, height: 800 });

                // 1. LOGIN
            console.log("   üîë Logging in...");
            await page.goto('https://twitter.com/i/flow/login', { waitUntil: 'networkidle2' });
            
            // Wait for username input
            await page.waitForSelector(TWITTER_SELECTORS.USERNAME_INPUT);
            await page.type(TWITTER_SELECTORS.USERNAME_INPUT, soldier.username);
            await new Promise(r => setTimeout(r, 500)); 
            
            // Click NEXT button (Crucial Step)
            // Strategy: Find all buttons, look for "Next" or "Siguiente" text, or use precise XPath if needed.
            // X often uses a 'span' inside a div with role='button'.
            // Let's use Puppeteer's text selector or reliable xpath
            const nextButton = await page.waitForSelector(TWITTER_SELECTORS.NEXT_BUTTON_XPATH);
            if (nextButton) {
                await nextButton.click();
            } else {
                // Fallback: Press Enter
                await page.keyboard.press('Enter');
            }
            
            await new Promise(r => setTimeout(r, 2000)); // Wait for transition

            // Wait for password input
            await page.waitForSelector(TWITTER_SELECTORS.PASSWORD_INPUT, { visible: true, timeout: 5000 });
            await page.type(TWITTER_SELECTORS.PASSWORD_INPUT, soldier.password);
            await page.keyboard.press('Enter');
            
            await page.waitForNavigation({ waitUntil: 'networkidle2' });
            console.log("   ‚úÖ Login successful.");

            // 2. NAVIGATE TO TARGET
            console.log("   üéØ Navigating to target...");
            // Use the validated targetUrl here
            await page.goto(targetUrl, { waitUntil: 'networkidle2' });
            await new Promise(r => setTimeout(r, 3000)); // Human pause

            // 3. ACTION (Reply/Like)
            // Like
            if (await page.$(TWITTER_SELECTORS.LIKE_BUTTON)) {
                await page.click(TWITTER_SELECTORS.LIKE_BUTTON);
                console.log("   ‚ù§Ô∏è Liked.");
            }

            // Reply
            const comment = COMMENTS[soldier.account_id];
            if (comment) {
                console.log(`   üí¨ Replying: "${comment}"`);
                
                // Click reply box (this selector is tricky and changes often, generic approach)
                // Focusing on the contenteditable div usually works
                await page.click(TWITTER_SELECTORS.REPLY_BUTTON); // Open modal or focus
                await new Promise(r => setTimeout(r, 1000));
                
                await page.keyboard.type(comment);
                await new Promise(r => setTimeout(r, 500));
                
                // Click Reply button
                await page.click(TWITTER_SELECTORS.TWEET_BUTTON);
                console.log("   üöÄ Reply sent.");
            }

            await new Promise(r => setTimeout(r, 5000)); // Wait to ensure send

            } catch (e) {
                console.error(`   ‚ùå FAILED: ${e.message}`);
            } finally {
                if (context) {
                    await context.close();
                }
            }
        }
    } finally {
        if (browser) {
            await browser.close();
        }
    }
}

if (require.main === module) {
    const inputUrl = process.argv[2] || DEFAULT_TARGET_URL;
    runSwarmAttack(inputUrl).catch(err => {
        console.error("‚ùå SWARM ATTACK FAILED:", err.message);
        process.exit(1);
    });
}

module.exports = { runSwarmAttack };
